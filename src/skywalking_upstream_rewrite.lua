---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zkq.
--- DateTime: 2019/12/24 12:32 PM
---
--package.cpath = package.cpath .. ';/Users/zkq/Library/Application Support/IntelliJIdea2018.2/intellij-emmylua/classes/debugger/emmy/mac/?.dylib'
--local dbg = require('emmy_core')
--dbg.tcpListen('localhost', 9966)
--dbg.waitIDE()
--dbg.breakHere()


local tracing_context = require("skywalking5.skywalking_tracing_context")

-- 创建tracing_context_instance 并设置到ctx全局变量中
local tracing_context_instance = tracing_context:new()

tracing_context_instance.trace_segment_id = tracing_context_instance.global_id_generator.generate()
if #tracing_context_instance.trace_segment_id == 0 then
    return
end

tracing_context_instance.related_global_trace_id = tracing_context_instance.global_id_generator.generate()
ngx.ctx.tracing_context_instance = tracing_context_instance
ngx.var.skywalking_trace_id=tracing_context_instance.related_global_trace_id

local app_code = skywalking_config.application_code

--upstream无法在发起请求请求前获取选中的负载服务器，只有在响应的header和body filter阶段有效
--local upstream_name = upstream.current_upstream_name()
--local addr = ngx.var.upstream_addr
----x:print("upstream_name="..upstream_name)
--x:print("addr="..addr)
--
--local srvs,err = upstream.get_primary_peers(upstream_name)
--local selected_ip_port = ""
--for _,s in ipairs(srvs) do
--    if string.find(addr,s.name,1,true) then
--        selected_ip_port = s.name
--    end
--end

print("skywalking trace_id="..tracing_context_instance.related_global_trace_id,",skywalking segment_id="..tracing_context_instance.trace_segment_id)
--ngx.log(ngx.INFO , "ngx.req.http_host:ngx.req.http_port"..ngx.req.http_host..ngx.req.http_port)


--- 第一步: 构造一个exit_span的数据
--参考org.apache.skywalking.apm.plugin.spring.resttemplate.async.RestExecuteInterceptor#beforeMethod
--String remotePeer = requestURL.getHost() + ":" + (requestURL.getPort() > 0 ? requestURL.getPort() : "https".equalsIgnoreCase(requestURL.getScheme()) ? 443 : 80);
--AbstractSpan span = ContextManager.createExitSpan(requestURL.getPath(), contextCarrier, remotePeer);
--根据请求的operation_name判断是否创建IgnoredTracerContext逻辑（过滤掉，图片，js，css等资源的请求），参考sw java agent：org.apache.skywalking.apm.agent.core.context.ContextManagerExtendService#createTraceContext
--TODO:完善IgnoredTracerContext逻辑
local exit_span_id = 0
-- 下面应该是反向代理到目标服务的路径，即出口路径，而非当前的ngx.var.uri。
--local exit_span_operation_name = ？？

-- 注意exit_span这里的remote指访问下一个节点的host:ip。命名来源于sw java agent: org.apache.skywalking.apm.agent.core.context.TracingContext#createExitSpan
-- 对应这里就是nginx upstream当前被选中的server，但是upstream无法在发起请求请求前获取选中的负载服务器，只有在响应的header和body filter阶段有效。所以这里为空
-- 林外分析sw 源码可知，在协议头中设置peerHost为空(仅有#字符)，对链路渲染无影响
local exit_span_remote_peer = ""

-- peerid需要通过服务端同步换取，sw java agent参考如下关键代码逻辑：
-- 1: org.apache.skywalking.apm.agent.core.dictionary.NetworkAddressDictionary#syncRemoteDictionary
-- 2: org.apache.skywalking.apm.agent.core.context.TracingContext#createExitSpan
-- 3: org.apache.skywalking.apm.agent.core.context.trace.ExitSpan中默认peerid=0
local exit_span_remote_peer_id = 0


--- 第二步: 构造ContextCarrier参数
-- 下面注释内容为java agent中cc是否合法的判断逻辑，其中getSpanId为当前segment中的exitspan。
--public boolean isValid() {
--return traceSegmentId != null
--&& traceSegmentId.isValid()
--&& getSpanId() > -1
--&& parentApplicationInstanceId != DictionaryUtil.nullValue()
--&& entryApplicationInstanceId != DictionaryUtil.nullValue()
--&& !StringUtil.isEmpty(peerHost)
--&& !StringUtil.isEmpty(entryOperationName)
--&& !StringUtil.isEmpty(parentOperationName)
--&& primaryDistributedTraceId != null;
--}

-- step 1
-- 协议描述:
-- The trace segment id is the unique id for the part of the distributed trace. Each id is only used in a single thread. The id includes three parts(Long), e.g. "1.2343.234234234
-- 实现说明:
-- 参考org.apache.skywalking.apm.agent.core.context.TracingContext#inject
local cc_trace_segment_id = tracing_context_instance.trace_segment_id

-- step 2
-- 协议描述:
-- An integer, unique in a trace segment. Start with 0;
-- 实现说明:
-- 参考org.apache.skywalking.apm.agent.core.context.TracingContext#inject
local cc_span_id = exit_span_id

-- step 3
-- 协议描述:
-- The instance id of the parent node, e.g. for a server of RPC, this id is from the client application instance id.
-- 实现说明:
-- ContextCarrier中的parentApplicationInstanceId从当前segment获取：segment.getApplicationInstanceId()；参考：org.apache.skywalking.apm.agent.core.context.TracingContext#inject
-- 本质即为客户端application instance id，正常逻辑需要通过服务端换取。这里默认为0
local cc_parent_application_instance_id = skywalking_config.get_instance_id()

-- step 4
-- 协议描述:
-- The instance id of the entry application. e.g. A distributed trace A->B->C, the id is from A.
-- 实现说明:
-- 这里简化，等同于cc_parent_application_instance_id，即：tracing_context.application_instance_id
-- 完整逻辑参考：org.apache.skywalking.apm.agent.core.context.TracingContext#inject
local cc_entry_application_instance_id = skywalking_config.get_instance_id()

-- step 5
-- 协议描述:
--The peer-host/peer-id from client side. e.g. client uses 182.14.39.1:9080 to access server, this ip:port is the peer host.
--This value can use exchange/compress collector service to get the id(integer) to represent the string. If you use the string, it must start with #, others use integer directly.
-- 实现说明:
-- 这里统一为字符串，peerid需要通过服务端同步换取，sw java agent参考如下关键代码逻辑：
-- 1: org.apache.skywalking.apm.agent.core.dictionary.NetworkAddressDictionary#syncRemoteDictionary
-- 2: org.apache.skywalking.apm.agent.core.context.TracingContext#createExitSpan
-- 3: org.apache.skywalking.apm.agent.core.context.trace.ExitSpan中默认peerid=0
-- 这里参考org.apache.skywalking.apm.agent.core.context.TracingContext#inject逻辑从exit_span中获取peer信息
local cc_peer_host
if exit_span_remote_peer_id == 0 then
    cc_peer_host = "#"..exit_span_remote_peer
else
    cc_peer_host = exit_span_remote_peer_id..""
end


-- step 6
-- 协议描述:
-- Entry Span Operation Name of First Trace Segment
-- The operation name/id of entry span propagates from Entry Application Instance.
-- This value can use exchange/compress collector service to get the id(integer) to represent the string. If you use the string, it must start with #, others use integer directly.
-- 实现说明:
-- 参考org.apache.skywalking.apm.agent.core.context.TracingContext#inject
-- 当前segment中span栈中的第一个span（一般为entry_span）。取ngx.var.uri数据。
-- 应该从first span（一般为entry_span）中获取(在rewrite_by_lua_file阶段创建)，这里简单处理。
-- 参考sw java agent逻辑，完整处理应该考虑上segment.getRefs()的逻辑。
-- nginx中入口ngx.var.uri既可以理解为first span的数据之一
local ngx_var = ngx.var
local cc_entry_operation_name = "#"..ngx_var.uri

-- step 7
-- 协议描述:
-- Entry Span Operation Name of Parent Trace Segment
-- The operation name/id of entry span propagates from Parent Application Instance.
-- This value can use exchange/compress collector service to get the id(integer) to represent the string. If you use the string, it must start with #, others use integer directly.
-- 实现说明:
-- 参考org.apache.skywalking.apm.agent.core.context.TracingContext#inject
-- 这里应该获取segment span栈中的第一个span的信息。
-- nginx中入口ngx.var.uri既可以理解为first span的数据之一
local cc_parent_peration_name =  "#"..ngx_var.uri

-- step 8
-- 协议描述:
-- Distributed Trace Id
-- The distributed trace id of the whole trace, if in a batch process, it comes from the trace of first batch producer. The rule is as same as Trace Segment Id with three Longs.
-- 实现说明:
-- 从skywalking_tracing_context中获取application_id
-- 参考org.apache.skywalking.apm.agent.core.context.TracingContext#inject
-- 可知该值是获取的distributedTraceIds.get(0)数据
-- 变量命名参考org.apache.skywalking.apm.agent.core.context.ContextCarrier#primaryDistributedTraceId
local cc_primary_distributed_trace_id = tracing_context_instance.related_global_trace_id

local sw3_header = cc_trace_segment_id.."|"..cc_span_id.."|"..cc_parent_application_instance_id.."|"..cc_entry_application_instance_id.."|"..cc_peer_host.."|"..cc_entry_operation_name.."|"..cc_parent_peration_name.."|"..cc_primary_distributed_trace_id
print("skywalking sw3_header="..sw3_header)

ngx.req.set_header("sw3",sw3_header)